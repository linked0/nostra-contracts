import { ethers } from "hardhat";

/**
 * Order Structure Inspector
 *
 * This script explains every field in a CTF Exchange order
 * to help understand the order structure and EIP-712 signing.
 *
 * Usage:
 * npx hardhat run packages/contracts/scripts/exchange/inspect-order.ts --network localhost
 */

enum Side { BUY = 0, SELL = 1 }
enum SignatureType { EOA = 0, POLY_PROXY = 1, POLY_GNOSIS_SAFE = 2 }

function separator(char = "━", width = 80) {
  console.log(char.repeat(width));
}

function header(text: string) {
  console.log(`\n${text}`);
  separator();
}

async function main() {
  header("CTF EXCHANGE - ORDER STRUCTURE INSPECTOR");

  const [maker, taker] = await ethers.getSigners();

  // Example order
  const tokenId = BigInt(ethers.id("YES_TOKEN"));
  const order = {
    salt: 1n,
    maker: maker.address,
    signer: maker.address,
    taker: ethers.ZeroAddress,
    tokenId: tokenId,
    makerAmount: ethers.parseUnits("100", 6),
    takerAmount: ethers.parseUnits("100", 6),
    expiration: BigInt(Math.floor(Date.now() / 1000) + 3600),
    nonce: 0n,
    feeRateBps: 100n, // 1%
    side: Side.SELL,
    signatureType: SignatureType.EOA,
    signature: "0x"
  };

  console.log("\nExample Order (SELL 100 YES tokens for 100 USDC):\n");

  // ═══════════════════════════════════════════════════════════════════
  // 1. IDENTITY FIELDS
  // ═══════════════════════════════════════════════════════════════════
  header("1. IDENTITY FIELDS - Who created this order?");

  console.log(`\n📋 salt: ${order.salt}`);
  console.log(`   Purpose: Makes the order unique (prevents hash collisions)`);
  console.log(`   Type: Random uint256`);
  console.log(`   Why: Two identical orders with same params need different hashes`);
  console.log(`   Example: If you want to create same order twice, change salt`);

  console.log(`\n👤 maker: ${order.maker}`);
  console.log(`   Purpose: Address that created and owns this order`);
  console.log(`   Type: Ethereum address`);
  console.log(`   Responsibility: Must have tokens/collateral to execute`);
  console.log(`   Example: If SELL order, maker must have outcome tokens`);

  console.log(`\n✍️  signer: ${order.signer}`);
  console.log(`   Purpose: Address that signed this order`);
  console.log(`   Type: Ethereum address`);
  console.log(`   Usually: Same as maker (for EOA wallets)`);
  console.log(`   Different when: Using smart contract wallets or delegates`);
  console.log(`   Example: Gnosis Safe (maker) with delegate signer`);

  console.log(`\n🎯 taker: ${order.taker}`);
  console.log(`   Purpose: Who is allowed to fill this order`);
  console.log(`   Type: Ethereum address`);
  console.log(`   0x0 (ZeroAddress): Anyone can fill (public order)`);
  console.log(`   Specific address: Only that address can fill (private/OTC)`);
  console.log(`   Example: Private deal between two known parties`);

  // ═══════════════════════════════════════════════════════════════════
  // 2. TRADE PARAMETERS
  // ═══════════════════════════════════════════════════════════════════
  header("2. TRADE PARAMETERS - What is being traded?");

  console.log(`\n🪙 tokenId: ${order.tokenId}`);
  console.log(`   Purpose: Identifies which outcome token is being traded`);
  console.log(`   Type: uint256 (ERC1155 token ID)`);
  console.log(`   Source: Generated by ConditionalTokens contract`);
  console.log(`   Format: positionId = keccak256(collateral, conditionId, indexSet)`);
  console.log(`   Example: YES token from "Will BTC hit $100k?" market`);

  console.log(`\n💰 makerAmount: ${ethers.formatUnits(order.makerAmount, 6)} (${order.makerAmount} wei)`);
  console.log(`   Purpose: Amount the MAKER is providing`);
  console.log(`   Type: uint256 (6 decimals for USDC/tokens)`);
  console.log(`   If SELL: Amount of outcome tokens maker is selling`);
  console.log(`   If BUY: Amount of USDC maker is offering to pay`);
  console.log(`   Current order: SELL → 100 YES tokens`);

  console.log(`\n💵 takerAmount: ${ethers.formatUnits(order.takerAmount, 6)} (${order.takerAmount} wei)`);
  console.log(`   Purpose: Amount the TAKER must provide`);
  console.log(`   Type: uint256 (6 decimals for USDC/tokens)`);
  console.log(`   If SELL: Amount of USDC taker must pay`);
  console.log(`   If BUY: Amount of outcome tokens taker must provide`);
  console.log(`   Current order: SELL → 100 USDC required`);

  console.log(`\n📊 Implied Price:`);
  const price = Number(order.takerAmount) / Number(order.makerAmount);
  console.log(`   ${price.toFixed(6)} USDC per token`);
  console.log(`   Calculation: takerAmount ÷ makerAmount`);
  console.log(`   ${ethers.formatUnits(order.takerAmount, 6)} USDC ÷ ${ethers.formatUnits(order.makerAmount, 6)} tokens = ${price}`);

  console.log(`\n📈 side: ${order.side === Side.BUY ? "BUY" : "SELL"}`);
  console.log(`   Purpose: Direction of the trade`);
  console.log(`   Type: enum Side { BUY = 0, SELL = 1 }`);
  console.log(`   BUY (0): Maker wants to buy outcome tokens (pay USDC)`);
  console.log(`   SELL (1): Maker wants to sell outcome tokens (receive USDC)`);
  console.log(`   Current: SELL → Maker has tokens, wants USDC`);

  // ═══════════════════════════════════════════════════════════════════
  // 3. VALIDITY FIELDS
  // ═══════════════════════════════════════════════════════════════════
  header("3. VALIDITY FIELDS - When and how is this order valid?");

  const expirationDate = new Date(Number(order.expiration) * 1000);
  console.log(`\n⏰ expiration: ${order.expiration} (${expirationDate.toISOString()})`);
  console.log(`   Purpose: Timestamp when order becomes invalid`);
  console.log(`   Type: uint256 (Unix timestamp in seconds)`);
  console.log(`   Validation: require(block.timestamp < expiration)`);
  console.log(`   Why: Prevents stale orders from being filled`);
  console.log(`   Example: Set to 1 hour for short-term trading`);

  console.log(`\n🔢 nonce: ${order.nonce}`);
  console.log(`   Purpose: Order sequence number for replay protection`);
  console.log(`   Type: uint256`);
  console.log(`   Validation: require(order.nonce >= currentNonce[maker])`);
  console.log(`   After fill: currentNonce[maker] = order.nonce + 1`);
  console.log(`   Effect: Order can only be filled once`);
  console.log(`   Example: Same order with same nonce cannot be replayed`);

  console.log(`\n💸 feeRateBps: ${order.feeRateBps} (${Number(order.feeRateBps) / 100}%)`);
  console.log(`   Purpose: Trading fee charged on this order`);
  console.log(`   Type: uint256 (basis points, 100 bps = 1%)`);
  console.log(`   Calculation: fee = (amount * feeRateBps) / 10000`);
  console.log(`   Example: 100 bps on 100 USDC = 1 USDC fee`);
  console.log(`   Max: 1000 bps (10%)`);
  console.log(`   Current: ${Number(order.feeRateBps) / 100}% = ${ethers.formatUnits((order.takerAmount * order.feeRateBps) / 10000n, 6)} USDC`);

  // ═══════════════════════════════════════════════════════════════════
  // 4. SIGNATURE
  // ═══════════════════════════════════════════════════════════════════
  header("4. SIGNATURE - How is authenticity verified?");

  console.log(`\n🔐 signatureType: ${order.signatureType}`);
  console.log(`   Purpose: Indicates wallet type for signature verification`);
  console.log(`   Type: enum SignatureType { EOA, POLY_PROXY, POLY_GNOSIS_SAFE }`);
  console.log(`   Values:`);
  console.log(`     0 (EOA): Standard wallet (MetaMask, Ledger, etc.)`);
  console.log(`     1 (POLY_PROXY): Polymarket proxy wallet`);
  console.log(`     2 (POLY_GNOSIS_SAFE): Gnosis Safe multisig wallet`);
  console.log(`   Current: ${SignatureType[order.signatureType]} → Standard wallet`);

  console.log(`\n✍️  signature: (65 bytes when signed)`);
  console.log(`   Purpose: Cryptographic proof that signer authorized this order`);
  console.log(`   Type: bytes (EIP-712 signature)`);
  console.log(`   Structure: [r (32 bytes)][s (32 bytes)][v (1 byte)]`);
  console.log(`   Generation:`);
  console.log(`     1. Create EIP-712 typed data structure`);
  console.log(`     2. Hash with domain separator`);
  console.log(`     3. Sign with private key`);
  console.log(`     4. Encode as bytes`);
  console.log(`   Verification:`);
  console.log(`     1. Recover signer from signature + hash`);
  console.log(`     2. Verify recovered address == order.signer`);

  // ═══════════════════════════════════════════════════════════════════
  // 5. EIP-712 DETAILS
  // ═══════════════════════════════════════════════════════════════════
  header("5. EIP-712 SIGNING - How signatures work");

  console.log(`\n📝 EIP-712 Structure:`);
  console.log(`   Standard: Typed structured data signing`);
  console.log(`   Benefits:`);
  console.log(`     • Human-readable in wallet (shows order details)`);
  console.log(`     • Domain separation (can't replay on other exchanges)`);
  console.log(`     • Type safety (prevents parameter confusion)`);

  console.log(`\n🏷️  Domain Separator (identifies the exchange):`);
  console.log(`   {`);
  console.log(`     name: "Nostra CTF Exchange",`);
  console.log(`     version: "1",`);
  console.log(`     chainId: 31337, // localhost, or 137 for Polygon`);
  console.log(`     verifyingContract: "0x..." // Exchange address`);
  console.log(`   }`);

  console.log(`\n📊 Type Definition:`);
  console.log(`   Order: [`);
  console.log(`     { name: "salt", type: "uint256" },`);
  console.log(`     { name: "maker", type: "address" },`);
  console.log(`     { name: "signer", type: "address" },`);
  console.log(`     { name: "taker", type: "address" },`);
  console.log(`     { name: "tokenId", type: "uint256" },`);
  console.log(`     { name: "makerAmount", type: "uint256" },`);
  console.log(`     { name: "takerAmount", type: "uint256" },`);
  console.log(`     { name: "expiration", type: "uint256" },`);
  console.log(`     { name: "nonce", type: "uint256" },`);
  console.log(`     { name: "feeRateBps", type: "uint256" },`);
  console.log(`     { name: "side", type: "uint8" },`);
  console.log(`     { name: "signatureType", type: "uint8" }`);
  console.log(`   ]`);

  console.log(`\n🔐 Hash Calculation:`);
  console.log(`   Step 1: Encode struct data`);
  console.log(`     structHash = keccak256(abi.encode(ORDER_TYPEHASH, order...))`);
  console.log(`   Step 2: Combine with domain`);
  console.log(`     digest = keccak256(0x1901 || domainSeparator || structHash)`);
  console.log(`   Step 3: Sign digest`);
  console.log(`     signature = sign(digest, privateKey)`);
  console.log(`   Result: Unique hash for this specific order on this exchange`);

  // ═══════════════════════════════════════════════════════════════════
  // 6. TRADE EXECUTION FLOW
  // ═══════════════════════════════════════════════════════════════════
  header("6. TRADE EXECUTION - What happens when order is filled?");

  console.log(`\n📋 Validation Checks (in order):`);
  console.log(`   1. ✓ Signature valid (recovers to order.signer)`);
  console.log(`   2. ✓ Not expired (block.timestamp < expiration)`);
  console.log(`   3. ✓ Nonce valid (nonce >= currentNonce[maker])`);
  console.log(`   4. ✓ Token registered (exchange knows this token)`);
  console.log(`   5. ✓ Maker has balance (enough tokens/USDC)`);
  console.log(`   6. ✓ Allowances granted (exchange can transfer)`);
  console.log(`   7. ✓ Fee valid (feeRateBps <= MAX_FEE)`);

  console.log(`\n💱 Transfer Flow (for this SELL order):`);
  console.log(`   1. Taker → Exchange: 100 USDC`);
  console.log(`   2. Exchange → Maker: 99 USDC (100 - 1% fee)`);
  console.log(`   3. Exchange keeps: 1 USDC (fee)`);
  console.log(`   4. Maker → Taker: 100 YES tokens (via exchange)`);

  console.log(`\n📊 State Updates:`);
  console.log(`   • orderStatus[orderHash] = filled amount`);
  console.log(`   • nonces[maker] = nonce + 1`);
  console.log(`   • Emit OrderFilled event`);

  // ═══════════════════════════════════════════════════════════════════
  // SUMMARY
  // ═══════════════════════════════════════════════════════════════════
  header("📚 SUMMARY - Quick Reference");

  console.log(`\nOrder Components at a Glance:`);
  console.log(`\n┌─────────────────┬────────────────────────────────────────────┐`);
  console.log(`│ Field           │ Purpose                                    │`);
  console.log(`├─────────────────┼────────────────────────────────────────────┤`);
  console.log(`│ salt            │ Uniqueness                                 │`);
  console.log(`│ maker           │ Order creator                              │`);
  console.log(`│ signer          │ Signature authority                        │`);
  console.log(`│ taker           │ Who can fill (0x0 = anyone)               │`);
  console.log(`│ tokenId         │ Which outcome token                        │`);
  console.log(`│ makerAmount     │ Maker's contribution                       │`);
  console.log(`│ takerAmount     │ Taker's contribution                       │`);
  console.log(`│ side            │ BUY or SELL                                │`);
  console.log(`│ expiration      │ Order deadline                             │`);
  console.log(`│ nonce           │ Replay protection                          │`);
  console.log(`│ feeRateBps      │ Trading fee                                │`);
  console.log(`│ signatureType   │ Wallet type                                │`);
  console.log(`│ signature       │ Cryptographic proof                        │`);
  console.log(`└─────────────────┴────────────────────────────────────────────┘`);

  console.log(`\nKey Insights:`);
  console.log(`  • Order is just data - doesn't execute until operator calls fillOrder`);
  console.log(`  • EIP-712 signature proves maker authorized this specific trade`);
  console.log(`  • Nonce ensures order can only be filled once (no replay)`);
  console.log(`  • Price = takerAmount ÷ makerAmount`);
  console.log(`  • Zero taker address = public order (anyone can fill)`);
  console.log(`  • Expiration prevents old orders from being executed`);
  console.log(`  • Signature type determines verification method`);

  separator();
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
