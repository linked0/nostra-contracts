import { ethers } from "hardhat";

/**
 * Order Structure Inspector
 *
 * This script explains every field in a CTF Exchange order
 * to help understand the order structure and EIP-712 signing.
 *
 * Usage:
 * npx hardhat run packages/contracts/scripts/exchange/inspect-order.ts --network localhost
 */

enum Side { BUY = 0, SELL = 1 }
enum SignatureType { EOA = 0, POLY_PROXY = 1, POLY_GNOSIS_SAFE = 2 }

function separator(char = "â”", width = 80) {
  console.log(char.repeat(width));
}

function header(text: string) {
  console.log(`\n${text}`);
  separator();
}

async function main() {
  header("CTF EXCHANGE - ORDER STRUCTURE INSPECTOR");

  const [maker, taker] = await ethers.getSigners();

  // Example order
  const tokenId = BigInt(ethers.id("YES_TOKEN"));
  const order = {
    salt: 1n,
    maker: maker.address,
    signer: maker.address,
    taker: ethers.ZeroAddress,
    tokenId: tokenId,
    makerAmount: ethers.parseUnits("100", 6),
    takerAmount: ethers.parseUnits("100", 6),
    expiration: BigInt(Math.floor(Date.now() / 1000) + 3600),
    nonce: 0n,
    feeRateBps: 100n, // 1%
    side: Side.SELL,
    signatureType: SignatureType.EOA,
    signature: "0x"
  };

  console.log("\nExample Order (SELL 100 YES tokens for 100 USDC):\n");

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 1. IDENTITY FIELDS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  header("1. IDENTITY FIELDS - Who created this order?");

  console.log(`\nğŸ“‹ salt: ${order.salt}`);
  console.log(`   Purpose: Makes the order unique (prevents hash collisions)`);
  console.log(`   Type: Random uint256`);
  console.log(`   Why: Two identical orders with same params need different hashes`);
  console.log(`   Example: If you want to create same order twice, change salt`);

  console.log(`\nğŸ‘¤ maker: ${order.maker}`);
  console.log(`   Purpose: Address that created and owns this order`);
  console.log(`   Type: Ethereum address`);
  console.log(`   Responsibility: Must have tokens/collateral to execute`);
  console.log(`   Example: If SELL order, maker must have outcome tokens`);

  console.log(`\nâœï¸  signer: ${order.signer}`);
  console.log(`   Purpose: Address that signed this order`);
  console.log(`   Type: Ethereum address`);
  console.log(`   Usually: Same as maker (for EOA wallets)`);
  console.log(`   Different when: Using smart contract wallets or delegates`);
  console.log(`   Example: Gnosis Safe (maker) with delegate signer`);

  console.log(`\nğŸ¯ taker: ${order.taker}`);
  console.log(`   Purpose: Who is allowed to fill this order`);
  console.log(`   Type: Ethereum address`);
  console.log(`   0x0 (ZeroAddress): Anyone can fill (public order)`);
  console.log(`   Specific address: Only that address can fill (private/OTC)`);
  console.log(`   Example: Private deal between two known parties`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 2. TRADE PARAMETERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  header("2. TRADE PARAMETERS - What is being traded?");

  console.log(`\nğŸª™ tokenId: ${order.tokenId}`);
  console.log(`   Purpose: Identifies which outcome token is being traded`);
  console.log(`   Type: uint256 (ERC1155 token ID)`);
  console.log(`   Source: Generated by ConditionalTokens contract`);
  console.log(`   Format: positionId = keccak256(collateral, conditionId, indexSet)`);
  console.log(`   Example: YES token from "Will BTC hit $100k?" market`);

  console.log(`\nğŸ’° makerAmount: ${ethers.formatUnits(order.makerAmount, 6)} (${order.makerAmount} wei)`);
  console.log(`   Purpose: Amount the MAKER is providing`);
  console.log(`   Type: uint256 (6 decimals for USDC/tokens)`);
  console.log(`   If SELL: Amount of outcome tokens maker is selling`);
  console.log(`   If BUY: Amount of USDC maker is offering to pay`);
  console.log(`   Current order: SELL â†’ 100 YES tokens`);

  console.log(`\nğŸ’µ takerAmount: ${ethers.formatUnits(order.takerAmount, 6)} (${order.takerAmount} wei)`);
  console.log(`   Purpose: Amount the TAKER must provide`);
  console.log(`   Type: uint256 (6 decimals for USDC/tokens)`);
  console.log(`   If SELL: Amount of USDC taker must pay`);
  console.log(`   If BUY: Amount of outcome tokens taker must provide`);
  console.log(`   Current order: SELL â†’ 100 USDC required`);

  console.log(`\nğŸ“Š Implied Price:`);
  const price = Number(order.takerAmount) / Number(order.makerAmount);
  console.log(`   ${price.toFixed(6)} USDC per token`);
  console.log(`   Calculation: takerAmount Ã· makerAmount`);
  console.log(`   ${ethers.formatUnits(order.takerAmount, 6)} USDC Ã· ${ethers.formatUnits(order.makerAmount, 6)} tokens = ${price}`);

  console.log(`\nğŸ“ˆ side: ${order.side === Side.BUY ? "BUY" : "SELL"}`);
  console.log(`   Purpose: Direction of the trade`);
  console.log(`   Type: enum Side { BUY = 0, SELL = 1 }`);
  console.log(`   BUY (0): Maker wants to buy outcome tokens (pay USDC)`);
  console.log(`   SELL (1): Maker wants to sell outcome tokens (receive USDC)`);
  console.log(`   Current: SELL â†’ Maker has tokens, wants USDC`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 3. VALIDITY FIELDS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  header("3. VALIDITY FIELDS - When and how is this order valid?");

  const expirationDate = new Date(Number(order.expiration) * 1000);
  console.log(`\nâ° expiration: ${order.expiration} (${expirationDate.toISOString()})`);
  console.log(`   Purpose: Timestamp when order becomes invalid`);
  console.log(`   Type: uint256 (Unix timestamp in seconds)`);
  console.log(`   Validation: require(block.timestamp < expiration)`);
  console.log(`   Why: Prevents stale orders from being filled`);
  console.log(`   Example: Set to 1 hour for short-term trading`);

  console.log(`\nğŸ”¢ nonce: ${order.nonce}`);
  console.log(`   Purpose: Order sequence number for replay protection`);
  console.log(`   Type: uint256`);
  console.log(`   Validation: require(order.nonce >= currentNonce[maker])`);
  console.log(`   After fill: currentNonce[maker] = order.nonce + 1`);
  console.log(`   Effect: Order can only be filled once`);
  console.log(`   Example: Same order with same nonce cannot be replayed`);

  console.log(`\nğŸ’¸ feeRateBps: ${order.feeRateBps} (${Number(order.feeRateBps) / 100}%)`);
  console.log(`   Purpose: Trading fee charged on this order`);
  console.log(`   Type: uint256 (basis points, 100 bps = 1%)`);
  console.log(`   Calculation: fee = (amount * feeRateBps) / 10000`);
  console.log(`   Example: 100 bps on 100 USDC = 1 USDC fee`);
  console.log(`   Max: 1000 bps (10%)`);
  console.log(`   Current: ${Number(order.feeRateBps) / 100}% = ${ethers.formatUnits((order.takerAmount * order.feeRateBps) / 10000n, 6)} USDC`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 4. SIGNATURE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  header("4. SIGNATURE - How is authenticity verified?");

  console.log(`\nğŸ” signatureType: ${order.signatureType}`);
  console.log(`   Purpose: Indicates wallet type for signature verification`);
  console.log(`   Type: enum SignatureType { EOA, POLY_PROXY, POLY_GNOSIS_SAFE }`);
  console.log(`   Values:`);
  console.log(`     0 (EOA): Standard wallet (MetaMask, Ledger, etc.)`);
  console.log(`     1 (POLY_PROXY): Polymarket proxy wallet`);
  console.log(`     2 (POLY_GNOSIS_SAFE): Gnosis Safe multisig wallet`);
  console.log(`   Current: ${SignatureType[order.signatureType]} â†’ Standard wallet`);

  console.log(`\nâœï¸  signature: (65 bytes when signed)`);
  console.log(`   Purpose: Cryptographic proof that signer authorized this order`);
  console.log(`   Type: bytes (EIP-712 signature)`);
  console.log(`   Structure: [r (32 bytes)][s (32 bytes)][v (1 byte)]`);
  console.log(`   Generation:`);
  console.log(`     1. Create EIP-712 typed data structure`);
  console.log(`     2. Hash with domain separator`);
  console.log(`     3. Sign with private key`);
  console.log(`     4. Encode as bytes`);
  console.log(`   Verification:`);
  console.log(`     1. Recover signer from signature + hash`);
  console.log(`     2. Verify recovered address == order.signer`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 5. EIP-712 DETAILS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  header("5. EIP-712 SIGNING - How signatures work");

  console.log(`\nğŸ“ EIP-712 Structure:`);
  console.log(`   Standard: Typed structured data signing`);
  console.log(`   Benefits:`);
  console.log(`     â€¢ Human-readable in wallet (shows order details)`);
  console.log(`     â€¢ Domain separation (can't replay on other exchanges)`);
  console.log(`     â€¢ Type safety (prevents parameter confusion)`);

  console.log(`\nğŸ·ï¸  Domain Separator (identifies the exchange):`);
  console.log(`   {`);
  console.log(`     name: "Nostra CTF Exchange",`);
  console.log(`     version: "1",`);
  console.log(`     chainId: 31337, // localhost, or 137 for Polygon`);
  console.log(`     verifyingContract: "0x..." // Exchange address`);
  console.log(`   }`);

  console.log(`\nğŸ“Š Type Definition:`);
  console.log(`   Order: [`);
  console.log(`     { name: "salt", type: "uint256" },`);
  console.log(`     { name: "maker", type: "address" },`);
  console.log(`     { name: "signer", type: "address" },`);
  console.log(`     { name: "taker", type: "address" },`);
  console.log(`     { name: "tokenId", type: "uint256" },`);
  console.log(`     { name: "makerAmount", type: "uint256" },`);
  console.log(`     { name: "takerAmount", type: "uint256" },`);
  console.log(`     { name: "expiration", type: "uint256" },`);
  console.log(`     { name: "nonce", type: "uint256" },`);
  console.log(`     { name: "feeRateBps", type: "uint256" },`);
  console.log(`     { name: "side", type: "uint8" },`);
  console.log(`     { name: "signatureType", type: "uint8" }`);
  console.log(`   ]`);

  console.log(`\nğŸ” Hash Calculation:`);
  console.log(`   Step 1: Encode struct data`);
  console.log(`     structHash = keccak256(abi.encode(ORDER_TYPEHASH, order...))`);
  console.log(`   Step 2: Combine with domain`);
  console.log(`     digest = keccak256(0x1901 || domainSeparator || structHash)`);
  console.log(`   Step 3: Sign digest`);
  console.log(`     signature = sign(digest, privateKey)`);
  console.log(`   Result: Unique hash for this specific order on this exchange`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 6. TRADE EXECUTION FLOW
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  header("6. TRADE EXECUTION - What happens when order is filled?");

  console.log(`\nğŸ“‹ Validation Checks (in order):`);
  console.log(`   1. âœ“ Signature valid (recovers to order.signer)`);
  console.log(`   2. âœ“ Not expired (block.timestamp < expiration)`);
  console.log(`   3. âœ“ Nonce valid (nonce >= currentNonce[maker])`);
  console.log(`   4. âœ“ Token registered (exchange knows this token)`);
  console.log(`   5. âœ“ Maker has balance (enough tokens/USDC)`);
  console.log(`   6. âœ“ Allowances granted (exchange can transfer)`);
  console.log(`   7. âœ“ Fee valid (feeRateBps <= MAX_FEE)`);

  console.log(`\nğŸ’± Transfer Flow (for this SELL order):`);
  console.log(`   1. Taker â†’ Exchange: 100 USDC`);
  console.log(`   2. Exchange â†’ Maker: 99 USDC (100 - 1% fee)`);
  console.log(`   3. Exchange keeps: 1 USDC (fee)`);
  console.log(`   4. Maker â†’ Taker: 100 YES tokens (via exchange)`);

  console.log(`\nğŸ“Š State Updates:`);
  console.log(`   â€¢ orderStatus[orderHash] = filled amount`);
  console.log(`   â€¢ nonces[maker] = nonce + 1`);
  console.log(`   â€¢ Emit OrderFilled event`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SUMMARY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  header("ğŸ“š SUMMARY - Quick Reference");

  console.log(`\nOrder Components at a Glance:`);
  console.log(`\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”`);
  console.log(`â”‚ Field           â”‚ Purpose                                    â”‚`);
  console.log(`â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤`);
  console.log(`â”‚ salt            â”‚ Uniqueness                                 â”‚`);
  console.log(`â”‚ maker           â”‚ Order creator                              â”‚`);
  console.log(`â”‚ signer          â”‚ Signature authority                        â”‚`);
  console.log(`â”‚ taker           â”‚ Who can fill (0x0 = anyone)               â”‚`);
  console.log(`â”‚ tokenId         â”‚ Which outcome token                        â”‚`);
  console.log(`â”‚ makerAmount     â”‚ Maker's contribution                       â”‚`);
  console.log(`â”‚ takerAmount     â”‚ Taker's contribution                       â”‚`);
  console.log(`â”‚ side            â”‚ BUY or SELL                                â”‚`);
  console.log(`â”‚ expiration      â”‚ Order deadline                             â”‚`);
  console.log(`â”‚ nonce           â”‚ Replay protection                          â”‚`);
  console.log(`â”‚ feeRateBps      â”‚ Trading fee                                â”‚`);
  console.log(`â”‚ signatureType   â”‚ Wallet type                                â”‚`);
  console.log(`â”‚ signature       â”‚ Cryptographic proof                        â”‚`);
  console.log(`â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`);

  console.log(`\nKey Insights:`);
  console.log(`  â€¢ Order is just data - doesn't execute until operator calls fillOrder`);
  console.log(`  â€¢ EIP-712 signature proves maker authorized this specific trade`);
  console.log(`  â€¢ Nonce ensures order can only be filled once (no replay)`);
  console.log(`  â€¢ Price = takerAmount Ã· makerAmount`);
  console.log(`  â€¢ Zero taker address = public order (anyone can fill)`);
  console.log(`  â€¢ Expiration prevents old orders from being executed`);
  console.log(`  â€¢ Signature type determines verification method`);

  separator();
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
